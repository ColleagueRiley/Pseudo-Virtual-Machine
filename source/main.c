
#ifdef _WIN32
#undef __linux__
#undef __unix__
#endif

#define RGFW_BUFFER
#define RGFW_IMPLEMENTATION

#define SI_IMPLEMENTATION

#include <stdbool.h>

#include "RGFW.h" /* simple multi-platform abstaction layer for creaing/managing windows */
#include "sili.h" /* standard toolchain stuff */
#include "draw.h" /* drawPixel and drawRect */

bool running = true;


/* 
note: one location in memory must be used as a timer
*/

char memory[4096];
char registers[16]; /* V0 - VF */

/* note : 
    VE is where random number outputs are sent to (probably generated by some ICs)
    VF is being used for controller input
*/

int main (int argc, char** argv) {
    srand(time(NULL));

    if (argc == 1) {
        printf("A rom file is required\n");
        return 1;
    }

    /* make sure there the rom is real */
    if (!si_path_exists(argv[1])) {
        printf("Rom file %s does not exist\n", argv[1]);
        return 1;
    }
    
    /* open rom and read it into a string */
    siFile f = si_file_open(argv[1]);
    siString filestr = si_file_read(f);

    si_file_close(f); /* close the file because we don't need it anymore */

    /* copy file string into RAM */
    int i; 
    for (i = 0; i < si_string_len(filestr); i++)
        memory[i] = filestr[i];

    RGFW_window* window = RGFW_createWindowPointer("Pseudo VM", 0, 0, 100, 100, RGFW_NO_RESIZE);

    int* screenSize = RGFW_getScreenSize(window);

    window->x = (screenSize[0] + 100) / 2;
    window->y = (screenSize[1] + 100) / 4;

    int N, X; /* vars [for checking bool for a while loop] */
    bool ifBool = true; /* bool for an if statement */
    
    int whileStart = -1; /* where the while loop starts (-1 means we're not in a while loop)  */

    for (i = 0; i < 4096 && running; i++) {

        /*
        *****opcodes****** 
        ==================
        0000   * close program or end while loop ( supported )
        1FXN   * if N == VX [do next line] ( supported / untested)
        1AXN   * while N == VX ( supported )
        DFXM   * dumps value at RAM address M into VX ( supported )
        DSXY   * sets V(S) to X and V(S + 1) to Y ( supported )
        DESX   * draws rectangle at (V(X), V(X + 1)) with w width of V(X + 3) and a height of V(X + 4)
        EEVM   * sets the value at RAM address M to V ( supported )
        A000   * generates a random number [0 - 100] into VE ( supported )
        C000   * clear screen ( supported )
        ==================
        */

        if (!ifBool) {
            ifBool = true;
            continue;
        }

        switch (memory[i]) {
            case '0':
                /* 0000 */
                if (memory[i++] == '0' && memory[i++] == '0' && memory[i++] == '0') { 
                    if (whileStart != -1 && N == registers[X]) {
                        i = whileStart;
                    }
                    else if (whileStart != -1 && N != memory[X])
                        whileStart = -1;

                    else 
                        running = false;
                }

                break;
            case '1':
                i++;

                if (memory[i] == 'F') {
                    i++;
                    X = registers[si_digit_to_int(memory[i])];
                    i++;
                    N =  si_digit_to_int(memory[i]);

                    ifBool = (X == N);
                }
                
                if (memory[i] == 'A') {
                    whileStart = i + 1;

                    i++;
                    
                    X = si_digit_to_int(memory[i]);
                    i++;
                    N =  si_digit_to_int(memory[i]);
                }
            
                break;

            case 'D':
                i++;
                
                if (memory[i] == 'F') { 
                    i++;

                    registers[si_digit_to_int(memory[i])] = memory[memory[i + 1]];
                }

                else if (memory[i] == 'E' && memory[i + 1] == 'S') {
                    i += 2;

                    int X = si_digit_to_int(memory[i]);
                    
                    drawRect(window, registers[X], registers[X + 1], registers[X + 2], registers[X + 3], (char[]){255, 255, 255});
                }

                else {
                    i++;
                    int X = si_digit_to_int(memory[i]);
                    i++;

                    int x = si_digit_to_int(memory[i]);

                    i++;
                    int y =  si_digit_to_int(memory[i]);

                    registers[X] = x;
                    registers[X + 1] = y;
                }

                break;

            case 'E':
                i++;
                
                if (memory[i] == 'E') {
                    i++;

                    memory[memory[i + 1]] = si_digit_to_int(memory[i]);
                }

                break;

            case 'A':
                /* A000 */
                if (memory[i++] == '0' && memory[i++] == '0' && memory[i++] == '0')
                    registers[14] = rand() % 100;

                break;

            case 'C':
                /* C000 */
                if (memory[i++] == '0' && memory[i++] == '0' && memory[i++] == '0')
                    clearScreen(window);

                break;
            default: break;
        }

        RGFW_checkEvents(window);

        switch (window->event.type) {
            case RGFW_quit: 
                running = false;
                break;

            case RGFW_keyPressed:
                if (window->event.keyName == "Up")
                    registers[15] = 1;
                else if (window->event.keyName == "Down")
                    registers[15] = 2;
                else if (window->event.keyName == "Left")
                    registers[15] = 3;
                else if (window->event.keyName == "Right")
                    registers[15] = 4;
                else if (window->event.keyName == "z")
                    registers[15] = 5;
                else if (window->event.keyName == "x")
                    registers[15] = 6;
                
                break;

            case RGFW_keyReleased:
                registers[15] = 0;
                break;
        }

        RGFW_swapBuffers(window);
    }

    RGFW_closeWindow(window);
}